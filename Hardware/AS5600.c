#include "AS5600.h"
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "sys.h"


/*?????*/

/**
  * ?    ?:I2C?SCL????
  * ?    ?:BitValue ????????????SCL???,??0~1
  * ? ? ?:?
  * ????:???????????,?BitValue?0?,???SCL????,?BitValue?1?,???SCL????
  */
void MyI2C_W_SCL(uint8_t BitValue)
{
	GPIO_WriteBit(GPIOB, GPIO_Pin_10, (BitAction)BitValue);		//??BitValue,??SCL?????
	Delay_us(10);												//??10us,??????????
}

/**
  * ?    ?:I2C?SDA????
  * ?    ?:BitValue ????????????SDA???,??0~0xFF
  * ? ? ?:?
  * ????:???????????,?BitValue?0?,???SDA????,?BitValue?0?,???SDA????
  */
void MyI2C_W_SDA(uint8_t BitValue)
{
	GPIO_WriteBit(GPIOB, GPIO_Pin_11, (BitAction)BitValue);		//??BitValue,??SDA?????,BitValue????0?1???
	Delay_us(10);												//??10us,??????????
}

/**
  * ?    ?:I2C?SDA????
  * ?    ?:?
  * ? ? ?:??????????SDA???,??0~1
  * ????:???????????,??SDA?????,??0,??SDA?????,??1
  */
uint8_t MyI2C_R_SDA(void)
{
	uint8_t BitValue;
	BitValue = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11);		//??SDA??
	Delay_us(10);												//??10us,??????????
	return BitValue;											//??SDA??
}

/**
  * ?    ?:I2C???
  * ?    ?:?
  * ? ? ?:?
  * ????:???????????,??SCL?SDA??????
  */
void MyI2C_Init(void)
{
	/*????*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);	//??GPIOB???
	
	/*GPIO???*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);					//?PB10?PB11??????????
	
	/*??????*/
	GPIO_SetBits(GPIOB, GPIO_Pin_10 | GPIO_Pin_11);			//??PB10?PB11????????????(??????)
}

/*???*/

/**
  * ?    ?:I2C??
  * ?    ?:?
  * ? ? ?:?
  */
void MyI2C_Start(void)
{
	MyI2C_W_SDA(1);							//??SDA,??SDA????
	MyI2C_W_SCL(1);							//??SCL,??SCL????
	MyI2C_W_SDA(0);							//?SCL?????,??SDA,??????
	MyI2C_W_SCL(0);							//????SCL???,???????,????????????
}

/**
  * ?    ?:I2C??
  * ?    ?:?
  * ? ? ?:?
  */
void MyI2C_Stop(void)
{
	MyI2C_W_SDA(0);							//??SDA,??SDA????
	MyI2C_W_SCL(1);							//??SCL,?SCL?????
	MyI2C_W_SDA(1);							//?SCL?????,??SDA,??????
}

/**
  * ?    ?:I2C??????
  * ?    ?:Byte ??????????,??:0x00~0xFF
  * ? ? ?:?
  */
void MyI2C_SendByte(uint8_t Byte)
{
	uint8_t i;
	for (i = 0; i < 8; i ++)				//??8?,????????????
	{
		MyI2C_W_SDA(Byte & (0x80 >> i));	//?????????Byte???????????SDA?
		MyI2C_W_SCL(1);						//??SCL,???SCL???????SDA
		MyI2C_W_SCL(0);						//??SCL,???????????
	}
}

/**
  * ?    ?:I2C??????
  * ?    ?:?
  * ? ? ?:??????????,??:0x00~0xFF
  */
uint8_t MyI2C_ReceiveByte(void)
{
	uint8_t i, Byte = 0x00;					//???????,????0x00,???????0x00,?????
	MyI2C_W_SDA(1);							//???,???????SDA,???????????
	for (i = 0; i < 8; i ++)				//??8?,????????????
	{
		MyI2C_W_SCL(1);						//??SCL,????SCL???????SDA
		if (MyI2C_R_SDA() == 1){Byte |= (0x80 >> i);}	//??SDA??,????Byte??
														//?SDA?1?,???????1,?SDA?0?,????,?????????0
		MyI2C_W_SCL(0);						//??SCL,???SCL???????SDA
	}
	return Byte;							//????????????
}

/**
  * ?    ?:I2C?????
  * ?    ?:Byte ???????,??:0~1,0????,1?????
  * ? ? ?:?
  */
void MyI2C_SendAck(uint8_t AckBit)
{
	MyI2C_W_SDA(AckBit);					//??????????SDA?
	MyI2C_W_SCL(1);							//??SCL,???SCL?????,?????
	MyI2C_W_SCL(0);							//??SCL,?????????
}

/**
  * ?    ?:I2C?????
  * ?    ?:?
  * ? ? ?:???????,??:0~1,0????,1?????
  */
uint8_t MyI2C_ReceiveAck(void)
{
	uint8_t AckBit;							//???????
	MyI2C_W_SDA(1);							//???,???????SDA,???????????
	MyI2C_W_SCL(1);							//??SCL,????SCL???????SDA
	AckBit = MyI2C_R_SDA();					//??????????
	MyI2C_W_SCL(0);							//??SCL,?????????
	return AckBit;							//?????????
}


/************************************************
读取AS5600角度(模拟I2C)
************************************************/

float full_rotations;    				//当前旋转圈数
float angle_prev;		 				//当前角度(用于位置环)
float vel_angle_prev;					//上次角度(用于位置环)
float angle_prev_Velocity;				//当前角度(用于速度环)
float vel_angle_prev_Velocity;			//上次角度(用于速度环)
unsigned long angle_prev_ts;			//当前的运行时间
unsigned long vel_angle_prev_ts;		//上次的运行时间


/**
  * 函    数：AS5600读寄存器
  * 参    数：RegAddress 寄存器地址，范围：参考AS5600手册的寄存器描述
  * 返 回 值：读取寄存器的数据，范围：0x00~0xFF
  */
uint8_t AS5600_ReadReg(uint8_t RegAddress)
{
	uint8_t Data;
	
	MyI2C_Start();						//I2C起始
	MyI2C_SendByte(AS5600_ADDRESS);	//发送从机地址，读写位为0，表示即将写入
	MyI2C_ReceiveAck();					//接收应答
	MyI2C_SendByte(RegAddress);			//发送寄存器地址
	MyI2C_ReceiveAck();					//接收应答
	
	MyI2C_Start();						//I2C重复起始
	MyI2C_SendByte(AS5600_ADDRESS | 0x01);	//发送从机地址，读写位为1，表示即将读取
	MyI2C_ReceiveAck();					//接收应答
	Data = MyI2C_ReceiveByte();			//接收指定寄存器的数据
	MyI2C_SendAck(1);					//发送应答，给从机非应答，终止从机的数据输出
	MyI2C_Stop();						//I2C终止	
	return Data;
}

/**
  * 函    数：AS5600初始化
  * 参    数：无
  * 返 回 值：无
  */
void AS5600_Init(void)
{
	MyI2C_Init();									//先初始化底层的I2C
	
}


/**
  * 函    数：AS5600获取数据
  * 参    数：
  * 参    数：
  * 返 回 值：无
  */
u16 AS5600_GetData(void)
{
	uint8_t DataH, DataL;								//定义数据高8位和低8位的变量
	
	DataH = AS5600_ReadReg(AS5600_ANGLE_H);		//读取加速度计X轴的高8位数据
	DataL = AS5600_ReadReg(AS5600_ANGLE_L);		//读取加速度计X轴的低8位数据
	//return (DataH << 8) | DataL;						//数据拼接，通过输出参数返回
	return LOWPass_Filter(((DataH << 8) | DataL),prefil,0.0);
	
}

/***********************************************
读取磁编码器360度值:(0°-360°)
***********************************************/
float get_Angle_360(void)
{
	
	return LOWPass_Filter((AS5600_GetData() * 0.08789),anglefil,0.5);
}



/***********************************************
读取磁编码器归一化弧度值:(0-6.28)
***********************************************/
float get_Angle_2PI(void)
{
	return AS5600_GetData() * 0.08789 / 57.32484; 
	
}


/***********************************************
磁编码器弧度制角度累计计算:(0-∞)
***********************************************/
float get_Angle(void)
{
	float val = get_Angle_2PI();
	float d_angle = val - angle_prev;
	//计算旋转的圈数
	//通过判断角度变化是否大于80%的一圈(0.8f*6.28318530718f)来判断是否发生了溢出
	//如果发生了溢出,则将full_rotations增加1(如果d_angle小于0)或减少1(如果d_angle大于0)
	if( fabs(d_angle) > (0.8f*6.28318530718f) )
		full_rotations += (d_angle > 0) ? -1 : 1;
	angle_prev = val;
	return (float)full_rotations * 6.28318530718f + angle_prev;
}
/***********************************************
磁编码器速度计算:(0-∞)
***********************************************/
//float getVelocity(void)
//{
////	float Ts, vel=0.0;

//	float vel=0.0;
////	//计算采样时间
////	angle_prev_ts = SysTick->VAL;
////	if(angle_prev_ts<vel_angle_prev_ts)Ts = (float)(vel_angle_prev_ts - angle_prev_ts)/9*1e-6;
////	else
////		Ts = (float)(0xFFFFFF - angle_prev_ts + vel_angle_prev_ts)/9*1e-6;
////	//快速修复微小溢出
////	if(Ts == 0 || Ts > 0.5) Ts = 1e-3f;
//	//记录当前角度
//	angle_prev_Velocity = get_Angle();
//	//变量存储
//	vel = (angle_prev_Velocity - vel_angle_prev_Velocity)*100;
//	vel_angle_prev_Velocity = angle_prev_Velocity;
//	//vel_angle_prev_ts = angle_prev_ts;

//	return vel;
//}



/***********************************************
磁编码器速度低通滤波计算:(0-∞)
***********************************************/
float get_Speed(void)
{
	float vel;
	angle_prev_Velocity = get_Angle();
	vel = (angle_prev_Velocity - vel_angle_prev_Velocity)*100;
	vel_angle_prev_Velocity = angle_prev_Velocity;
	
	//原始数据低通滤波
	float vel_M0_flit_1=LOWPass_Filter(FOC_Parame.DIR*vel,speedfil_1,0.8);
	float vel_M0_flit=LOWPass_Filter(vel_M0_flit_1,speedfil_2,0.8);	
	int16_t temp = (int16_t)vel_M0_flit*100;
	return (float)temp/100;
}
